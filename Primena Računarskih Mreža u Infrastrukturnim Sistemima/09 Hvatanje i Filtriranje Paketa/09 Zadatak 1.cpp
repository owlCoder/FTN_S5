// We do not want the warnings about the old deprecated and unsecure CRT functions since these examples can be compiled under *nix as well
#ifdef _MSC_VER
	#define _CRT_SECURE_NO_WARNINGS
#endif

// Include libraries
#include <stdlib.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include "pcap.h"
#include "conio.h"

int packet_counter = 0;	// numerates each packet

// Function declarations
pcap_if_t* select_device(pcap_if_t* devices);
void packet_handler(unsigned char *param, const struct pcap_pkthdr *packet_header, const unsigned char *packet_data);

int main()
{
	pcap_if_t *devices;						// List of network interface controllers
	pcap_if_t *device;						// Network interface controller
	pcap_t* device_handle;					// Descriptor of capture device
	char error_buffer[PCAP_ERRBUF_SIZE];	// Error buffer
    
    /* Retrieve the device list on the local machine */
    if (pcap_findalldevs(&devices, error_buffer) == -1)
	{
		printf("Error in pcap_findalldevs: %s\n", error_buffer);
		return -1;
	}
    
	// Chose one device from the list
	device = select_device(devices);
	
	// Check if device is valid
	if (device == NULL)
	{
		pcap_freealldevs(devices);
		return -1;
	}

    // Open the capture device
    if ((device_handle = pcap_open_live( device->name,		// name of the device
                              65536,						// portion of the packet to capture (65536 guarantees that the whole packet will be captured on all the link layers)
                              1,							// promiscuous mode
                              500,							// read timeout
							  error_buffer					// buffer where error message is stored
							) ) == NULL)
    {
        printf("\nUnable to open the adapter. %s is not supported by WinPcap\n", device->name);
        pcap_freealldevs(devices);
        return -1;
    }
    
	// 1. Omogućiti da se obrađuju samo dolazni paketi adresirani na logičku adresu računara 
    // na kome je pokrenuta aplikacija i koji za transport koriste TCP protokol.
    // Predfiltriranje paketa vršiti na kernelu korišćenjem pcap_compile() i
    // pcap_setfilter()
    unsigned int netmask;
    char filter_exp[] = "tcp and ip dst host 192.168.0.101";
    struct bpf_program fcode;
    if (device->addresses != NULL)
        // Retrieve the mask of the first address of the interface 
        netmask = ((struct sockaddr_in*)(device->addresses->netmask))
        ->sin_addr.s_addr;
    else
        // If the interface is without an address
        // we suppose to be in a C class network 
        netmask = 0xffffff;
    // Compile the filter
    if (pcap_compile(device_handle, &fcode, filter_exp, 1, netmask) < 0)
    {
        printf("\n Unable to compile the packet filter. Check the syntax.\n");
        return -1;
    }
    // Set the filter
    if (pcap_setfilter(device_handle, &fcode) < 0)
    {
        printf("\n Error setting the filter.\n");
        return -1;
    }



    printf("\nListening on %s...\n", device->description);
    
    // At this point, we don't need any more the device list. Free it 
    pcap_freealldevs(devices);
    
    // Start the capture
    // pcap_loop(device_handle, 0, packet_handler, NULL);
    
    // Modifikovati rešenje tako da se omogući hvatanje paketa bez callback funkcije.
    int result; // result of pcap_next_ex function
    int packet_counter = 0; // counts packets in order to have numerated packets 
    struct pcap_pkthdr* packet_header; // header of packet generated by WinPcap 
    const unsigned char* packet_data; // packet content

    // Retrieve the packets
    while ((result = pcap_next_ex(device_handle, &packet_header, &packet_data)) >= 0)
    {
        // Check if timeout has elapsed 
        if (result == 0)
            continue;

        // Print timestamp and length of the packet
        time_t timestamp;			// Raw time (bits) when packet is received 
        struct tm* local_time;		// Local time when packet is received
        char time_string[16];		// Local time converted to string

        // Convert the timestamp to readable format
        timestamp = packet_header->ts.tv_sec;
        local_time = localtime(&timestamp);
        strftime(time_string, sizeof time_string, "%H:%M:%S", local_time);

        printf("\n-------------------------------------------");
        printf("\nPacket (%d): %s, %d byte\n", ++packet_counter, time_string, packet_header->len);
        
        // Ispisati sirovi sadržaj svakog primljenog paketa packet_data koristeći
        // heksadecimalan zapis. U jednom redu prikazati najviše 32 bajta.
        printf("\n================================== DATA ====================================\n");
        for (unsigned i = 0, j = 0; i < packet_header->len; i++)
        {
            if (i == 0)
            {
                printf("Line [%d]: %x", ++j, packet_data[i]);
            }
            else if (i % 32 == 0)
            {
                printf("%x\nLine [%d]: ", packet_data[i], ++j);
            }
            else
            {
                printf("%x", packet_data[i]);
            }
        }
        printf("\n============================================================================\n");
    }
    if (result == -1) {
        printf("Error reading the packets: %s\n", pcap_geterr(device_handle));
        return -1;
    }

    
    return 0;
}

// This function provide possibility to chose device from the list of available devices
pcap_if_t* select_device(pcap_if_t* devices)
{
	int i=0;	// Count devices and provide jumping to the selected device 
	pcap_if_t* device;

    // Print the list
    for(device=devices; device; device=device->next)
    {
        printf("%d. %s", ++i, device->name);
        if (device->description)
            printf(" (%s)\n", device->description);
        else
            printf(" (No description available)\n");
    }
    
    if(i==0)
    {
        printf("\nNo interfaces found! Make sure WinPcap is installed.\n");
        return NULL;
    }
    
	// Pick one device from the list
	int device_number;
    printf("Enter the interface number (1-%d):",i);
    scanf_s("%d", &device_number);
    
    if(device_number < 1 || device_number > i)
    {
        printf("\nInterface number out of range.\n");
        return NULL;
    }
    
     // Jump to the selected device
    for(device=devices, i=0; i< device_number-1 ;device=device->next, i++);

	return device;  
}

// Callback function invoked by WinPcap for every incoming packet
void packet_handler(unsigned char* param, const struct pcap_pkthdr* packet_header, const unsigned char* packet_data)
{
	// Print timestamp and length of the packet
	time_t timestamp;			// Raw time (bits) when packet is received 
	struct tm* local_time;		// Local time when packet is received
	char time_string[16];		// Local time converted to string

	// Convert the timestamp to readable format
	timestamp = packet_header->ts.tv_sec;
	local_time = localtime(&timestamp);
	strftime( time_string, sizeof time_string, "%H:%M:%S", local_time);
	
	printf("\n-------------------------------------------");
	printf("\nPacket (%d): %s, %d byte\n", ++packet_counter, time_string, packet_header->len);


    // Ispisati sirovi sadržaj svakog primljenog paketa packet_data koristeći
    // heksadecimalan zapis. U jednom redu prikazati najviše 32 bajta.
    printf("\n================================== DATA ====================================\n");
    for (unsigned i = 0, j = 0; i < packet_header->len; i++)
    {
        if (i == 0)
        {
            printf("Line [%d]: %x", ++j, packet_data[i]);
        }
        else if (i % 32 == 0)
        {
            printf("%x\nLine [%d]: ", packet_data[i], ++j);
        }
        else
        {
            printf("%x", packet_data[i]);
        }
    }
    printf("\n============================================================================\n");
}